# Roadmap для нейросети: чеклист с подробными шагами

**Краткое назначение:** этот документ — пошаговый чеклист действий, которые нейросеть (или автоматизированный агент) должна выполнять для реализации функции: *по вводу названия аккорда* подобрать аппликатуру на шестиструнной гитаре и воспроизвести аккорд, объединяя заранее записанные mp3-сэмплы каждой струны/лада.

> **Инструкция по использованию для нейросети:** при запуске каждого шага нейросеть должна: 1) прочитать цель и вход/выход шага; 2) выполнить шаг, фиксируя результаты; 3) отметить чекбокс как ✅ только после успешной проверки по критериям готовности; 4) если критерии не выполнены — добавить запись об ошибке и вернуться к описанию шага для исправления.

---

## Пример формата шага (обязательно читать перед началом)

* [ ] **Шаг 1: Подготовить структуру сэмплов** — цель: стандартная папка `samples/` с 6 папками струн и файлами `fret0.mp3`…`fret4.mp3`. *Критерий готовности:* все файлы читаются и нормально декодируются `AudioContext.decodeAudioData`.

---

## 1. Подготовка базы сэмплов

* [ ] **Цель:** создать однозначную, машиночитаемую структуру хранения аудиосэмплов.
* **Вход:** набор mp3 файлов отдельных нот по струнам/ладам; доступ к файловой системе/облаку.
* **Выход:** структура `samples/{string}/{fret}.mp3` + `notes.json` с соответствиями частот/нот.
* **Описание (подробно):**

  1. Создать папки: `samples/E A D G B e` (имена чувствительны к регистру: верхняя/нижняя тональность).
  2. Поместить файлы в формате `fret{N}.mp3`, где `N` от 0 до 4 (0 — открытая).
  3. Сгенерировать `notes.json` — словарь, где ключ струна, значение — массив нотовых имен для ладов 0..4 (например: `"E": ["E2","F2","F#2","G2","G#2"]`).
  4. Проверить каждый файл: команда-псевдокод для проверки целостности и декодирования:

     ```bash
     for f in samples/**/*; do
       ffmpeg -v error -i "$f" -f null - || echo "BAD: $f";
     done
     ```
* **Критерии готовности:** все файлы проходят проверку ffmpeg, `notes.json` корректно парсится, отсутствуют дубли и пропуски.
* **Что делать при ошибке:** пометить шаг как "ошибка", записать какой файл некорректен, вернуть файл на стадию перезаписи/конвертации.

---

## 2. Нормализация и приведение сэмплов к единому формату

* [ ] **Цель:** обеспечить единообразную громкость, длину и частотные характеристики.
* **Вход:** `samples/` и `notes.json`.
* **Выход:** файлы mp3 (или wav) с одинаковым RMS-показателем, одинаковой частотой дискретизации (рекомендация: 44.1 kHz) и длиной (например, 3 сек).
* **Подробно:**

  1. Для каждого файла вычислить RMS/медиану громкости, определить целевой уровень (-18 LUFS или RMS target).
  2. Использовать `ffmpeg`/`sox` для нормализации и приведения sample rate:

     ```bash
     ffmpeg -i in.mp3 -ar 44100 -af loudnorm=I=-18:LRA=7:TP=-1 out.wav
     ```
  3. Обрезать/дополнить тишиной до фиксированной длительности (например, 3s) для синхронного старта при стэкинге.
* **Критерии готовности:** RMS/LUFS по всем файлам находится в пределах ±1 dB от целевого; все файлы 44.1 kHz и длиной 3s.

---

## 3. Формализация нотации и парсер аккордов

* [ ] **Цель:** разработать модуль `parseChord(chordName) -> [noteNames]`.
* **Вход:** строка аккорда от пользователя (пример: `C#m7`, `G`, `Fmaj7`, `Bm`).
* **Выход:** массив нот (без октав), например `['C#','E','G#','B']`.
* **Подробно:**

  1. Использовать библиотеку tonal (или реализовать правило): поддерживать вариации: `maj`, `m`, `dim`, `aug`, `7`, `maj7`, `m7`, `sus2`, `sus4`, `add9`, `6`.
  2. Парсер должен:

     * Нормализовать ввод (убрать пробелы, привести #/b к унифицированной записи).
     * Обрабатывать неявную мажор (т.е. `C` -> `Cmaj`).
     * Возвращать набор ступеней (набор нотов без октавы).
  3. Псевдокод проверки:

     ```js
     const notes = parseChord('C#m7'); // -> ['C#','E','G#','B']
     assert(Array.isArray(notes) && notes.length >= 2);
     ```
* **Критерии готовности:** для 100 тестовых аккордов (стандартный набор из 200) парсер возвращает правильный набор нот в 98%+ случаев.

---

## 4. Матчинг нот аккорда с возможными позициями на гитаре

* [ ] **Цель:** для каждой ноты аккорда найти *все* возможные (струна, лад) комбинации в пределах ладов 0..4.
* **Вход:** `notes.json` (маппинг струн->нот) и массив нот аккорда.
* **Выход:** словарь: `note -> [ {string, fret, midi, octave} ]`.
* **Подробно:**

  1. Пройти по каждой струне и каждому ладу 0..4 и сравнить нотовое имя (без октавы) с нотой аккорда.
  2. Вернуть список всех совпадений.
  3. Логировать отсутствующие соответствия (например, если у ноты нет позиций в 0..4 — пометить).
* **Критерии готовности:** для каждого нота в аккорде найден минимум одна позиция (если нет — шаг отмечен как предупреждение и требуется расширение набора сэмплов/ладов).

---

## 5. Поиск оптимальной аппликатуры (эвристический алгоритм)

* [ ] **Цель:** выбрать именно одну позицию струны+лада для каждой из 6 струн (или пометить струну как "немота" для отсутствующих)
* **Вход:** вывод шага 4 (возможные позиции для каждой ноты), список ограничений: максимум растяжения между ладами (рекомендовано: 4), минимальное количество пальцев, приоритет открытых струн.
* **Выход:** аппликатура в формате: `[ {string:'E', fret:0, note:'E'}, ... ]` для 6 струн.
* **Подробно (алгоритм):**

  1. Построить граф вариантов: для каждой струны — набор допустимых ладов (включая mute).
  2. Генерировать комбинации (с учётом, что общий порядок — 6 струн) — если полный перебор слишком велик, использовать жадную эвристику:

     * Первично выбрать позиции для басовой ноты аккорда (root) на низких струнах.
     * Для соседних струн выбирать позицию, минимизирующую диапазон (maxFret - minFret).
     * Применять штрафы за баррэ (если несколько ладов совпадают на одном ладу).
  3. Оценочная функция (score) = w1*(−диапазон) + w2*(кол-во открытых струн) + w3*(мин. кол-во баррэ) + w4*(соответствие стандартным аккордам в базе).
  4. Вернуть топ-N аппликатур и пометить лучшую.
* **Критерии готовности:** найдено хотя бы 1 аппликатура с score выше заранее заданного порога; если нет — вернуть лучшие N и пометку "ручная проверка".

---

## 6. Сопоставление аппликатуры с аудиофайлами (map to samples)

* [ ] **Цель:** для каждой струны в аппликатуре найти конкретный файл `samples/{string}/fret{N}.wav`.
* **Вход:** аппликатура (шаг 5) и файловая структура (шаг 1-2).
* **Выход:** список путей к аудиофайлам.
* **Подробно:**

  1. Если струна помечена как `mute` — пропуск, генерировать короткий silent buffer вместо файла.
  2. Подтянуть `samples/{string}/fret{fret}.wav`. Если файла нет — попытаться транспонировать ближайший лад с pitch-shift (см. шаг 8).
* **Критерии готовности:** все 6 строчек имеют либо аудиофайл, либо silent buffer, либо успешную альтернативную трансформацию.

---

## 7. Загрузка и кэширование аудиобуферов (Inference-ready)

* [ ] **Цель:** загрузить и декодировать все нужные файлы в память как `AudioBuffer` для моментального запуска.
* **Вход:** список путей из шага 6.
* **Выход:** объект `buffers[string] = AudioBuffer`.
* **Подробно:**

  1. Для каждой ссылки вызвать `fetch` и `decodeAudioData` (в браузере) или использовать серверный декодер.
  2. Кешировать результат в оперативной памяти/Redis/сборке статических ресурсов.
  3. Таймауты: если загрузка >5s — пометить предупреждение и попытаться загрузить альтернативный файл.
* **Критерии готовности:** все требуемые буферы декодированы и валидны.

---

## 8. Альтернативы: транспонирование и временная подгонка

* [ ] **Цель:** при отсутствии точного сэмпла обеспечить корректную аудио-замену через pitch-shift/time-stretch.
* **Вход:** отсутствующий аудиофайл, ближайший доступный лад/семпл.
* **Выход:** модифицированный `AudioBuffer`, подходящий по тону и длительности.
* **Подробно:**

  1. Использовать алгоритм pitch-shift без изменения темпа (WSOLA/phase vocoder) на ±1–2 полутона максимум.
  2. Для более крупных сдвигов — пометить как низкое качество и предложить запись нужного сэмпла.
  3. Код-псевдодействие (WebAudio API): создать offline AudioContext, применить `playbackRate` и/или специализированную библиотеку (`soundtouch`, `pitch-shift`).
* **Критерии готовности:** итоговый буфер содержит нужную ноту в пределах ±30 центов; в лог добавляется метка о трансформации.

---

## 9. Синхронное воспроизведение (минимизация латентности)

* [ ] **Цель:** одновременно стартовать все 6 источников так, чтобы результат воспринимался как единый аккорд.
* **Вход:** `AudioBuffer` для каждой струны.
* **Выход:** воспроизведение; отчет о времени старта и задержках.
* **Подробно:**

  1. В браузере использовать `AudioContext.currentTime` и `bufferSource.start(startTime)` для всех источников с одной и той же меткой `startTime = currentTime + 0.05`.
  2. Для реалистичности — добавить слегка вариативные задержки/амплитуды (по умолчанию 0 ms задержка для одновременного аккорда).
  3. Для арпеджио — задавать offset между струнами (например, 20–100 ms).
* **Критерии готовности:** замеры времени воспроизведения показывают сдвиги < 20 ms между струнами при одновременном запуске.

---

## 10. Интеграция с UI: ввод, визуализация и управление

* [ ] **Цель:** создать интерфейс, где пользователь вводит аккорд и нажимает Play/Stop, видит аппликатуру и прогресс.
* **Вход:** API вызовы: `POST /play` с полем `chordName` или локальный JS-вызов `playChord('Am')`.
* **Выход:** UI-ответ, визуализация грифа, подсказки.
* **Подробно:**

  1. Поле ввода с автокомплитом аккордов (база из 200+ аккордов).
  2. Отрисовать гриф (SVG) и подсветить выбранные лады. При воспроизведении подсветка мигает.
  3. Логирование каждого пользовательского запроса и времени отклика.
* **Критерии готовности:** end-to-end latency < 500 ms (при кешированном буфере), UI показывает корректную аппликатуру и статус воспроизведения.

---


### Финальные указания для нейросети (чтобы возвращаться к описанию и точнее выполнять задачи)

1. Перед выполнением шага  — прочитать цель, вход, выход и критерии готовности.
2. После выполнения — сравнить реальный результат с критериями; при несоответствии записать причину и попытаться исправить (повторить шаг или откатить изменения).
3. Каждое действие логировать (timestamp, входные данные, вывод, время выполнения, метрики).
4. При достижении критерия — отметить чекбокс и зафиксировать артефакты (файлы, модели, логи).

